
scheme wkbb18 {
  groups fluid {
    select type fluid;

    varying field x = real[] position;
    varying field v = real[] velocity;
    varying field a = real[] acceleration;

    varying field rho = real density;
    varying field m   = real mass;

    uniform field rho0 = real rest_density;
    uniform field nu   = real viscosity;

    varying field vd = real[]   wkbb18_velocity_delta;
    varying field sd = real[][] wkbb18_system_diagonal;
  }

  groups boundary {
    select type boundary;

    varying field x = real[] position;

    varying field V = real volume;
    
    uniform field nu = real viscosity;
  }

  global {
    field h = real smoothing_scale;
    field dt = real time_step;
  }

  procedure compute_diagonal {
    foreach fluid particle f {
      // reset the diagonal element vector
      compute sd[f] = zeros<real[][]>();

      // accumulate over fluid neighbors
      foreach fluid neighbor f_f {
        compute sd[f] +=
            10 // HACK: this is actually a dimensionality correction factor (10 in 3D, 8 in 2D)
          *
            nu[f]
          *
            (m[f_f] / rho[f_f])
          /
            (norm_squared(x[f] - x[f_f]) + 0.01 * h * h)
          *
            outer_product(
              kernel_gradient_h(x[f] - x[f_f], h),
              x[f] - x[f_f]
            )
          ;
      }

      // accumulate over boundary neighbors
      foreach boundary neighbor f_b {
        compute sd[f] +=
            10 // HACK: this is actually a dimensionality correction factor (10 in 3D, 8 in 2D)
          *
            nu[f_b]
          *
            (rho0[f] * V[f_b] / rho[f])
          /
            (norm_squared(x[f] - x[f_b]) + 0.01 * h * h)
          *
            outer_product(
              kernel_gradient_h(x[f] - x[f_b], h),
              x[f] - x[f_b]
            )
        ;
      }

      compute sd[f] = identity<real[][]>() - dt / rho[f] * sd[f];
    }
  }

  procedure accumulate_acceleration {
    solve cg real[] over fluid particle f {
      setup right_hand_side into result {
        compute result[f] = v[f];
      }

      setup guess into iterate {
        compute iterate[f] = v[f] + vd[f];
      }

      product preconditioner with iterate into result {
        compute result[f] = sp[f] * iterate[f];
      }

      product system with iterate into result {
        local a_f : real[] = zeros<real[]>();

        foreach fluid neighbor f_f {
          compute a_f += 
              10 // HACK: this is actually a dimensionality correction factor (10 in 3D, 8 in 2D)
            *
              nu[f]
            *
              (m[f_f] / rho[f_f])
            *
              dot(iterate[f] - iterate[f_f], x[f] - x[f_f])
            /
              (norm_squared(x[f] - x[f_f]) + 0.01 * h * h)
            *
              kernel_gradient_h(x[f] - x[f_f], h);
        }

        foreach boundary neighbor f_b {
          compute a_f += 
              10 // HACK: this is actually a dimensionality correction factor (10 in 3D, 8 in 2D)
            *
              nu[f]
            *
              (rho0[f] * V[f_b] / rho[f])
            *
              dot(iterate[f], x[f] - x[f_b])
            /
              (norm_squared(x[f] - x[f_b]) + 0.01 * h * h)
            *
              kernel_gradient_h(x[f] - x[f_b], h);
        }

        compute result[f] -= dt / rho[f] * a_f;
      }

      apply iterate {
        compute vd[f] = iterate[f] - v[f];
        compute a[f] += vd[f] / dt;
      }
    }
  }
}


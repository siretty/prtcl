
scheme pt16 {
  groups fluid {
    select type fluid;

    varying field x = real[] position;
    varying field v = real[] velocity;
    varying field a = real[] acceleration;

    varying field rho = real density;
    varying field m = real mass;

    varying field L = real[][] gradient_correction;

    uniform field rho0 = real rest_density;

    varying field t_birth = real time_of_birth;

    varying field pt16_one = real pt16_normalizer;
    varying field pt16_rho = real pt16_density;

    varying field omega = real[] vorticity;

    varying field tvg = real[][] target_velocity_gradient;

    varying field omega_diagonal = real   pt16_vorticity_diffusion_diagonal;
    varying field omega_rhs      = real[] pt16_vorticity_diffusion_rhs;

    varying field v_rec_diagonal = real   pt16_velocity_reconstruction_diagonal;
    varying field v_rec_rhs      = real[] pt16_velocity_reconstruction_rhs;

    uniform field xi = real strain_rate_viscosity;

    uniform field pcg_max_error  = real    pt16_maximum_error;
    uniform field pcg_max_iters  = integer pt16_maximum_iterations;
    uniform field pcg_iterations = integer pt16_iterations;
  }

  groups boundary {
    select type boundary;

    varying field x = real[] position;
    varying field V = real volume;
  }

  global {
    field h = real smoothing_scale;
    field dt = real time_step;

    field t = real current_time;
    field dt_fade = real fade_duration;
  }

  procedure setup {
    foreach fluid particle f {
      // initialize the normalizer 
      compute pt16_one[f] = 0;

      foreach fluid neighbor f_f {
        // accumulate the normalizer from fluid neighbors
        compute pt16_one[f] +=
            (m[f_f] / rho[f_f])
          *
            kernel_h(x[f] - x[f_f], h);
      }

      foreach boundary neighbor f_b {
        // accumulate the normalizer from boudary neighbors
        compute pt16_one[f] +=
            V[f_b]
          *
            kernel_h(x[f] - x[f_b], h);
      }

      // compute the density using the normalizer
      compute pt16_rho[f] = rho0[f] * pt16_one[f];
    }
  }

  procedure compute_velocity_gradient {
    foreach fluid particle f {
      // initialize the velocity gradient with zeros
      local vg_f : real[][] = zeros<real[][]>();

      //foreach particle neighbor f_f {
      //  // accumulate the velocity gradient
      //  compute vg_f +=
      //      (m[f_f] / rho[f_f])
      //    *
      //      outer_product(
      //        v[f_f] - v[f],
      //        L[f] * kernel_gradient_h(x[f] - x[f_f], h)
      //      );
      //}
      //compute vg_f *= 1 / pt16_one[f];

      local rho_f : real = 0;
      foreach particle neighbor f_f {
        // accumulate the velocity gradient
        compute vg_f +=
            m[f_f]
          *
            outer_product(
              v[f_f] - v[f],
              L[f] * kernel_gradient_h(x[f] - x[f_f], h)
            );
        compute rho_f += m[f_f] * kernel_h(x[f] - x[f_f], h);
      }
      compute vg_f *= 1 / rho_f;

      // decompose the velocity gradient into spin, expansion and shear rate
      local divergence_f : real = trace(vg_f);
      local R_f : real[][] = (vg_f - transpose(vg_f)) / 2;
      local V_f : real[][] = (divergence_f / 3) * identity<real[][]>();
      local S_f : real[][] = (vg_f + transpose(vg_f)) / 2 - V_f;

      // extract the vorticity from the spin rate
      compute omega[f] = 2 * vector_from_cross_product_matrix(R_f);

      // partially compose the target velocity gradient (without spin rate)
      compute tvg[f] =
          unit_step_r(0, rho[f] - rho0[f], -divergence_f)
        *
          V_f
        +
          xi[f] * S_f;

      //compute tvg[f] += R_f;

      // // compute fluid-only density for the vorticity diffusion system
      // local fluid_rho_f : real = zeros<real>();
      // foreach particle neighbor f_f {
      //   compute fluid_rho_f += m[f_f] * kernel_h(x[f] - x[f_f], h);
      // }

      // // compute the diagonal element of the vorticity diffusion system
      // compute omega_diagonal[f] = fluid_rho_f - m[f] * kernel_h(zeros<real[]>(), h);

      // // compute the diagonal element of the velocity reconstruction system
      // compute v_rec_diagonal[f] = rho[f] - m[f] * kernel_h(zeros<real[]>(), h);
    }
  }

  // procedure compute_vorticity_rhs {
  //   // compute the right-hand-side of the vorticity diffusion system
  //   foreach fluid particle f {
  //     compute omega_rhs[f] = zeros<real[]>();
  //     foreach fluid neighbor f_f {
  //       compute omega_rhs[f] +=
  //           xi[f]
  //         *
  //           m[f_f]
  //         *
  //           (omega[f] - omega[f_f])
  //         *
  //           kernel_h(x[f] - x[f_f], h);
  //     }
  //   }
  // }

  procedure solve_vorticity_diffusion {
    solve pcg real[] over fluid particle f {
      setup right_hand_side into result {
        local rhs : real[] = zeros<real[]>();

        foreach fluid neighbor f_f {
          compute rhs +=
              xi[f]
            *
              m[f_f]
            *
              (omega[f] - omega[f_f])
            *
              kernel_h(x[f] - x[f_f], h);
        }

        compute result[f] = rhs;
      }

      setup guess into result {
        compute result[f] = omega[f];
      }

      product preconditioner with iterate into result {
        // TODO: implement preconditioner
        compute result[f] = iterate[f];
      }

      product system with iterate into result {
        local tmp : real[] = zeros<real[]>();
        local rho_f : real = 0;

        foreach particle neighbor f_f {
          compute tmp -=
              m[f_f]
            *
              kernel_h(x[f] - x[f_f], h)
            *
              iterate[f_f];

          compute rho_f += m[f_f] * kernel_h(x[f] - x[f_f], h);
        }

        compute result[f] = rho_f * iterate[f] + tmp;
      }

      apply iterate {
        // finalize the target vorticity
        compute omega[f] = iterate[f] * unit_step_l(0, (t - t_birth[f]) - dt_fade);
        // add the target spin rate (from the target vorticity) to the velocity gradient
        compute tvg[f] += cross_product_matrix_from_vector(0.5 * omega[f]);
      }
    }
  }

  // procedure compute_target_velocity_gradient {
  //   foreach fluid particle f {
  //     // add the target spin rate (from the diffused vorticity) to the velocity gradient
  //     compute tvg[f] += cross_product_matrix_from_vector(omega[f] / 2);
  //   }
  // }
  //   
  // procedure compute_velocity_reconstruction_rhs {
  //   // compute the right-hand-side of the velocity reconstruction system
  //   foreach fluid particle f {
  //     compute v_rec_rhs[f] = zeros<real[]>();
  //     foreach fluid neighbor f_f {
  //       compute v_rec_rhs[f] +=
  //           m[f_f]
  //         *
  //           ((0.5 * tvg[f] + 0.5 * tvg[f_f]) * (x[f] - x[f_f]))
  //         *
  //           kernel_h(x[f] - x[f_f], h);
  //     }
  //   }
  // }

  procedure solve_velocity_reconstruction {
    solve pcg real[] over fluid particle f {
      setup right_hand_side into result {
        local rhs : real[] = zeros<real[]>();

        foreach fluid neighbor f_f {
          compute rhs +=
              (m[f_f] / rho[f_f])
            *
              0.5 * ((tvg[f] + tvg[f_f]) * (x[f] - x[f_f]))
            *
              kernel_h(x[f] - x[f_f], h);
        }

        compute result[f] = (1 / pt16_one[f]) * rhs;
      }

      setup guess into iterate {
        compute iterate[f] = v[f];
      }

      product preconditioner with iterate into result {
        // TODO: implement preconditioner
        compute result[f] = iterate[f];
      }

      product system with iterate into result {
        local tmp : real[] = zeros<real[]>();

        foreach fluid neighbor f_f {
          compute tmp -=
              (m[f_f] / rho[f_f])
            *
              kernel_h(x[f] - x[f_f], h)
            *
              iterate[f_f];
        }

        compute result[f] = iterate[f] + (1 / pt16_one[f]) * tmp;
      }

      apply iterate {
        // implement fade-in of particles by applying the resulting iterate
        // after the fade was completed and the previous velocity if the
        // particle is still fading in
        //compute v[f] =
        //    iterate[f] * unit_step_l(0, (t - t_birth[f]) - dt_fade)
        //  +
        //    v[f] * unit_step_r(0, dt_fade - (t - t_birth[f]));

        //compute v[f] = iterate[f] * unit_step_l(0, (t - t_birth[f]) - dt_fade);

        // compute the viscosity acceleration
        compute a[f] = (iterate[f] - v[f]) / dt;
      }
    }
  }
}


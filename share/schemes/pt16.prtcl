
scheme pt16 {
  groups fluid {
    select type fluid;

    varying field x = real[] position;
    varying field v = real[] velocity;
    varying field a = real[] acceleration;

    varying field rho = real density;
    varying field m = real mass;

    uniform field rho0 = real rest_density;

    varying field omega = real[] vorticity;

    varying field vg  = real[][] velocity_gradient;
    varying field tvg = real[][] target_velocity_gradient;

    varying field omega_diagonal = real   pt16_vorticity_diffusion_diagonal;
    varying field omega_rhs      = real[] pt16_vorticity_diffusion_rhs;

    varying field v_rec_diagonal = real   pt16_velocity_reconstruction_diagonal;
    varying field v_rec_rhs      = real[] pt16_velocity_reconstruction_rhs;

    uniform field xi = real pt16_viscosity;
  }

  global {
    field h = real smoothing_scale;
    field dt = real time_step;
  }

  procedure compute_velocity_gradient_and_vorticity {
    foreach fluid particle f {
      // compute the velocity gradient
      local vg_f : real[][] = zeros<real[][]>();

      foreach fluid neighbor f_f {
        compute vg_f +=
            m[f_f] / rho[f]
          *
            outer_product(
              v[f_f] - v[f],
              kernel_gradient_h(x[f] - x[f_f], h)
            );
      }

      compute vg[f] = vg_f;

      // decompose the velocity gradient into spin, expansion and shear rate
      local divergence_f : real = trace(vg_f);
      local R_f : real[][] = (vg_f - transpose(vg_f)) / 2;
      local V_f : real[][] = (divergence_f / 3) * identity<real[][]>();
      local S_f : real[][] = (vg_f + transpose(vg_f)) / 2 - V_f;

      // extract the vorticity from the spin rate
      compute omega[f] = 2 * vector_from_cross_product_matrix(R_f);

      // partially compose the target velocity gradient (without spin rate)
      compute tvg[f] =
          unit_step_r(0, rho[f] - rho0[f], divergence_f)
        *
          V_f
        +
          xi[f] * S_f;

      // compute fluid-only density for the vorticity diffusion system
      local fluid_rho_f : real = zeros<real>();
      foreach fluid neighbor f_f {
        compute fluid_rho_f += m[f_f] * kernel_h(x[f] - x[f_f], h);
      }

      // compute the diagonal element of the vorticity diffusion system
      compute omega_diagonal[f] = fluid_rho_f - m[f] * kernel_h(zeros<real[]>(), h);

      // compute the diagonal element of the velocity reconstruction system
      compute v_rec_diagonal[f] = rho[f] - m[f] * kernel_h(zeros<real[]>(), h);
    }
  }

  procedure compute_vorticity_rhs {
    // compute the right-hand-side of the vorticity diffusion system
    foreach fluid particle f {
      compute omega_rhs[f] = zeros<real[]>();
      foreach fluid neighbor f_f {
        compute omega_rhs[f] +=
            xi[f]
          *
            m[f_f]
          *
            (omega[f] - omega[f_f])
          *
            kernel_h(x[f] - x[f_f], h);
      }
    }
  }

  procedure compute_target_velocity_gradient {
    foreach fluid particle f {
      // add the target spin rate (from the diffused vorticity) to the velocity gradient
      compute tvg[f] += cross_product_matrix_from_vector(omega[f] / 2);
    }
  }
    
  procedure compute_velocity_reconstruction_rhs {
    // compute the right-hand-side of the velocity reconstruction system
    foreach fluid particle f {
      compute v_rec_rhs[f] = zeros<real[]>();
      foreach fluid neighbor f_f {
        compute v_rec_rhs[f] +=
            m[f_f]
          *
            ((0.5 * tvg[f] + 0.5 * tvg[f_f]) * (x[f] - x[f_f]))
          *
            kernel_h(x[f] - x[f_f], h);
      }
    }
  }
}

//linear_system vorticity_diffusion {
//  diagonal (field result) {
//    foreach fluid particle f {
//      // compute fluid-only density for the vorticity diffusion system
//      local fluid_rho_f : real = zeros<real>;
//      foreach fluid neighbor f_f {
//        compute fluid_rho_f += m[f_f] * kernel_h(x[f] - x[f_f], h);
//      }
//
//      // compute the diagonal element of the vorticity diffusion system
//      compute result[f] = fluid_rho_f - m[f] * kernel_h(zeros<real[]>, h);
//    }
//  }
//
//  product (field omega, field result) {
//    foreach fluid particle f {
//      // compute fluid-only density for the vorticity diffusion system
//      local fluid_rho_f : real = zeros<real>;
//      foreach fluid neighbor f_f {
//        compute fluid_rho_f += m[f_f] * kernel_h(x[f] - x[f_f], h);
//      }
//
//      // compute the product at the diagonal element
//      compute result[f] = (fluid_rho_f - m[f] * kernel_h(zeros<real[]>, h)) * omega[f];
//
//      // accumulate the off-diagonal elements
//      foreach fluid particle f_f {
//        result[f] -= m[f_f] * kernel_h(x[f] - x[f_f], h) * omega[f_f];
//      }
//    }
//  }
//}

